#!/usr/bin/env python3
"""Push-to-talk bridge for Handy on GNOME Wayland.

Hold Ctrl+/ to start recording via Handy (SIGUSR2), release to stop.
Waits for Handy to update the clipboard, then pastes via ydotool.
"""

import os
import signal
import subprocess
import sys
import threading
import time
import evdev
from evdev import ecodes
from selectors import DefaultSelector, EVENT_READ

KEY_LEFTCTRL = ecodes.KEY_LEFTCTRL
KEY_RIGHTCTRL = ecodes.KEY_RIGHTCTRL
KEY_SLASH = ecodes.KEY_SLASH


def find_keyboards():
    """Find real keyboard devices (exclude virtual/ydotool devices)."""
    devices = []
    for path in evdev.list_devices():
        dev = evdev.InputDevice(path)
        caps = dev.capabilities()
        keys = caps.get(ecodes.EV_KEY, [])
        if KEY_LEFTCTRL in keys and KEY_SLASH in keys:
            try:
                num = int(path.split("event")[-1])
                if num > 100:
                    dev.close()
                    continue
            except ValueError:
                pass
            devices.append(dev)
    return devices


def send_sigusr2():
    """Send SIGUSR2 to the handy process."""
    try:
        result = subprocess.run(
            ["pgrep", "-x", "handy"],
            capture_output=True, text=True
        )
        pid = result.stdout.strip()
        if pid:
            os.kill(int(pid), signal.SIGUSR2)
            return True
    except Exception:
        pass
    return False


def get_clipboard():
    """Get current clipboard contents."""
    try:
        result = subprocess.run(
            ["wl-paste", "--no-newline"],
            capture_output=True, text=True, timeout=2
        )
        return result.stdout
    except Exception:
        return ""


def paste_via_ydotool():
    """Send Ctrl+V via ydotool."""
    try:
        subprocess.run(
            ["ydotool", "key", "--delay", "0", "ctrl+v"],
            timeout=5,
            capture_output=True
        )
        return True
    except Exception as e:
        print(f"  paste error: {e}", file=sys.stderr, flush=True)
        return False


def wait_and_paste(clip_before):
    """Poll clipboard until it changes, then paste."""
    for _ in range(60):  # up to 6 seconds
        time.sleep(0.1)
        current = get_clipboard()
        if current != clip_before and current.strip():
            time.sleep(0.1)
            paste_via_ydotool()
            print(f"  pasted: {current.strip()[:80]}", flush=True)
            return
    print("  timeout waiting for transcription", file=sys.stderr, flush=True)


def main():
    keyboards = find_keyboards()
    if not keyboards:
        print("No keyboards found. Are you in the 'input' group?",
              file=sys.stderr, flush=True)
        sys.exit(1)

    print(f"Handy PTT: monitoring {len(keyboards)} keyboard(s):", flush=True)
    for kb in keyboards:
        print(f"  {kb.path}: {kb.name}", flush=True)

    selector = DefaultSelector()
    for kb in keyboards:
        selector.register(kb, EVENT_READ)

    ctrl_held = False
    recording = False

    def cleanup(signum=None, frame=None):
        for kb in keyboards:
            try:
                selector.unregister(kb)
                kb.close()
            except Exception:
                pass
        selector.close()
        sys.exit(0)

    signal.signal(signal.SIGTERM, cleanup)
    signal.signal(signal.SIGINT, cleanup)

    try:
        while True:
            for key, mask in selector.select():
                device = key.fileobj
                try:
                    for event in device.read():
                        if event.type != ecodes.EV_KEY:
                            continue

                        if event.value == 2:
                            continue

                        if event.code in (KEY_LEFTCTRL, KEY_RIGHTCTRL):
                            if event.value == 1:
                                ctrl_held = True
                            elif event.value == 0:
                                ctrl_held = False
                                if recording:
                                    recording = False
                                    clip_before = get_clipboard()
                                    send_sigusr2()
                                    print("  stop (ctrl released)", flush=True)
                                    threading.Thread(
                                        target=wait_and_paste,
                                        args=(clip_before,),
                                        daemon=True
                                    ).start()

                        elif event.code == KEY_SLASH:
                            if event.value == 1 and ctrl_held and not recording:
                                recording = True
                                send_sigusr2()
                                print("  recording...", flush=True)
                            elif event.value == 0 and recording:
                                recording = False
                                clip_before = get_clipboard()
                                send_sigusr2()
                                print("  stop (/ released)", flush=True)
                                threading.Thread(
                                    target=wait_and_paste,
                                    args=(clip_before,),
                                    daemon=True
                                ).start()
                except OSError:
                    pass
    except KeyboardInterrupt:
        pass
    finally:
        cleanup()


if __name__ == "__main__":
    main()
