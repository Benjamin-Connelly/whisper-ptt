#!/usr/bin/env python3
"""Push-to-talk speech-to-text using faster-whisper.

Hold Right Ctrl to record, release to transcribe and type.
All processing is 100% local â€” nothing leaves your machine.

Mic stays open for instant capture (no clipping). Whisper's VAD
filter strips silence so the pre/post buffers don't add noise.
"""

import os
import signal
import subprocess
import sys
import threading
import time
import numpy as np
import sounddevice as sd
import evdev
from evdev import ecodes
from selectors import DefaultSelector, EVENT_READ

KEY_RIGHTCTRL = ecodes.KEY_RIGHTCTRL

SAMPLE_RATE = 16000
MODEL_SIZE = os.environ.get("WHISPER_MODEL", "medium.en")
PRE_BUFFER_SECS = 2
PRE_BUFFER_SAMPLES = SAMPLE_RATE * PRE_BUFFER_SECS
TRAIL_SECS = 0.5

# Globals
model = None
audio_buffer = []
pre_buffer = []
buffer_lock = threading.Lock()
recording = False


def _setup_cuda_paths():
    """Add CUDA libraries from the venv to LD_LIBRARY_PATH if available."""
    venv = os.environ.get("VIRTUAL_ENV") or sys.prefix
    site_pkgs = os.path.join(venv, "lib", f"python{sys.version_info.major}.{sys.version_info.minor}", "site-packages")
    cublas = os.path.join(site_pkgs, "nvidia", "cublas", "lib")
    cudnn = os.path.join(site_pkgs, "nvidia", "cudnn", "lib")
    cuda_libs = ":".join(p for p in (cublas, cudnn) if os.path.isdir(p))
    if cuda_libs:
        existing = os.environ.get("LD_LIBRARY_PATH", "")
        os.environ["LD_LIBRARY_PATH"] = f"{cuda_libs}:{existing}" if existing else cuda_libs


_setup_cuda_paths()


def load_model():
    from faster_whisper import WhisperModel
    print("Loading Whisper model on CUDA...", flush=True)
    try:
        m = WhisperModel(MODEL_SIZE, device="cuda", compute_type="float16")
        print("Model loaded (CUDA float16).", flush=True)
    except Exception as e:
        print(f"CUDA failed ({e}), falling back to CPU...", flush=True)
        m = WhisperModel(MODEL_SIZE, device="cpu", compute_type="int8")
        print("Model loaded (CPU int8).", flush=True)
    return m


def find_keyboards():
    devices = []
    for path in evdev.list_devices():
        dev = evdev.InputDevice(path)
        caps = dev.capabilities()
        keys = caps.get(ecodes.EV_KEY, [])
        if KEY_RIGHTCTRL in keys:
            try:
                num = int(path.split("event")[-1])
                if num > 100:
                    dev.close()
                    continue
            except ValueError:
                pass
            devices.append(dev)
    return devices


def audio_callback(indata, frames, time_info, status):
    chunk = indata[:, 0].copy()
    with buffer_lock:
        if recording:
            audio_buffer.append(chunk)
        else:
            pre_buffer.append(chunk)
            total = sum(len(c) for c in pre_buffer)
            while total > PRE_BUFFER_SAMPLES and len(pre_buffer) > 1:
                total -= len(pre_buffer[0])
                pre_buffer.pop(0)


def start_recording():
    global recording
    with buffer_lock:
        audio_buffer.clear()
        audio_buffer.extend(pre_buffer)
        pre_buffer.clear()
    recording = True


def stop_and_transcribe():
    global recording

    time.sleep(TRAIL_SECS)
    recording = False

    with buffer_lock:
        if not audio_buffer:
            print("  no audio captured", flush=True)
            return
        audio = np.concatenate(audio_buffer)
        audio_buffer.clear()

    duration = len(audio) / SAMPLE_RATE
    if duration < 0.3:
        print(f"  too short ({duration:.1f}s), skipping", flush=True)
        return

    print(f"  transcribing {duration:.1f}s...", flush=True)
    t0 = time.time()

    segments, info = model.transcribe(
        audio,
        beam_size=5,
        language="en",
        vad_filter=True,
        vad_parameters=dict(min_silence_duration_ms=500),
    )

    text = " ".join(seg.text.strip() for seg in segments).strip()
    elapsed = time.time() - t0

    if not text:
        print(f"  no speech detected ({elapsed:.1f}s)", flush=True)
        return

    print(f"  [{elapsed:.1f}s] {text}", flush=True)

    # Copy to clipboard
    try:
        proc = subprocess.Popen(["wl-copy"], stdin=subprocess.PIPE)
        proc.communicate(input=text.encode(), timeout=3)
    except Exception:
        pass

    # Type text directly
    time.sleep(0.3)
    try:
        subprocess.run(
            ["ydotool", "type", "--delay", "50", "--key-delay", "4", "--", text],
            timeout=30, capture_output=True
        )
    except Exception as e:
        print(f"  type error: {e}", file=sys.stderr, flush=True)


def main():
    global model

    keyboards = find_keyboards()
    if not keyboards:
        print("No keyboards found. Are you in the 'input' group?",
              file=sys.stderr, flush=True)
        sys.exit(1)

    model = load_model()

    stream = sd.InputStream(
        samplerate=SAMPLE_RATE,
        channels=1,
        dtype="float32",
        callback=audio_callback,
        blocksize=1024,
    )
    stream.start()

    print("Push-to-talk ready (hold Right Ctrl to record):", flush=True)
    for kb in keyboards:
        print(f"  {kb.path}: {kb.name}", flush=True)

    selector = DefaultSelector()
    for kb in keyboards:
        selector.register(kb, EVENT_READ)

    is_recording = False

    def cleanup(signum=None, frame=None):
        stream.stop()
        stream.close()
        for kb in keyboards:
            try:
                selector.unregister(kb)
                kb.close()
            except Exception:
                pass
        selector.close()
        sys.exit(0)

    signal.signal(signal.SIGTERM, cleanup)
    signal.signal(signal.SIGINT, cleanup)

    try:
        while True:
            for key, mask in selector.select():
                device = key.fileobj
                try:
                    for event in device.read():
                        if event.type != ecodes.EV_KEY:
                            continue
                        if event.value == 2:
                            continue

                        if event.code == KEY_RIGHTCTRL:
                            if event.value == 1 and not is_recording:
                                is_recording = True
                                start_recording()
                                print("  recording...", flush=True)
                            elif event.value == 0 and is_recording:
                                is_recording = False
                                print("  released", flush=True)
                                threading.Thread(
                                    target=stop_and_transcribe,
                                    daemon=True
                                ).start()
                except OSError:
                    pass
    except KeyboardInterrupt:
        pass
    finally:
        cleanup()


if __name__ == "__main__":
    main()
